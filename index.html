<!doctype html>
<html lang="en">
<head>

    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    
    <title>Vulcan</title>
    
    <link href='https://fonts.googleapis.com/css?family=PT+Sans:400,700,400italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet/less" type="text/css" href="stylesheet.less"/>
    
    <script src="scripts/less.min.js" type="text/javascript"></script>
    <script src="scripts/main.js"></script>
    
</head>

<body>
    <article>
    
        <h1>Vulcan</h1>
        
            <p>Vulcan is an online PCB editor. Most other editors use a grid-based routing system, but Vulcan uses a funky topographic algorithm for 
            routing the traces. (Think of rubber bands stretched around obstacles like pads or other traces.) As a pleasant side effect, using 
            topographic routing should also allow me to implement cool stuff like push-aside routing and auto-complete.</p>
            
        <h2>Why Use Topographic Routing?</h2>
            
            <p>Almost all PCB editors available today use grid-based routing. Vertices can only be placed in discrete locations, and tracks change 
            direction in 45&deg; or 90&deg; increments. Here's what you see when editing a board in Eagle PCB:</p>
            
            <figure>
                <img src="images/gridrouter.png" alt="A PCB which uses grid routing">
                <figcaption>Figure 1</figcaption>
            </figure>
            
            <p>The biggest problem with grid-based routing is that it confuses form (the exact position of each track segment) with function ("make 
            the track go between these two components, then clockwise around this pin"). In contrast, topographic routing only allows the user to 
            specify function; the position of each track segment is controlled entirely by the editor. This makes it very easy to refactor the PCB.</p>
            
        <h2>Functional Specification</h2>
        
            <h3>Wrapping</h3>
            <p>manual, mouse-driven, automatic completion, keep-out zones.</p>
            
        <h2>The Wrapping Algorithm</h2>
            
            <p>We begin by showing that the wrapping algorithm can wrap around circular obstacles. This is the fundamental example, because all 
            polygons can be wrapped as if they were a set of circular obstacles.</p>
            
            <figure id="firstExample">
                <figcaption>Figure 2: &nbsp; This route demonstrates all possible wrapping relations, such as center-to-clockwise and clockwise-to-
                counterclockwise wraps.</figcaption>
            </figure>
            
            <p>An explanation of the first example.</p>
            
            <figure id="thirdExample">
                <figcaption>Figure 3: &nbsp; How to find the inner tangent of two circles.</figcaption>
            </figure>
            
            
    </article>
</body>
</html>